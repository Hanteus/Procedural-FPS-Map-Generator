\chapter{Features of the research framework}

% INTRODUCTION %

In this chapter we describe the \<framework> that we have developed to perform user-based online validation for researches in procedural content generation of multiplayer levels for Firsts Person Shooters. In the first section we give an overview of the framework, of its features and of its components, analyzing them one by one in the following sections.

% FRAMEWORK OVERVIEW 

\section{Overview}

We designed our framework with the objective of providing a valid alternative to the games currently employed as a validation tool in this research field. All the available options, like \<Cube 2: Sauerbraten>, are powerful tools to perform validation via artificial agents, but they are not suitable for user-based validation. A data-collection campaign based on these games requires to download the game or to take part in real-life play-test sessions, but these options discourage potential participants because they are significantly time-consuming. For this reason, we decided to develop a framework that is as light as possible, with a WebGL build weighting less than 10MB that can be played using any browser. The framework was developed with Unity.

\par

Since the purpose of this tool is to be used in research, we decided to support many map representation formats used in previous works and we designed our framework to be as modular, expansible and configurable as possible.

\section{The framework structure}

The framework collects data by assigning to the users \<matches> to play. A match is defined by the \<game mode> and by the \<map type>, which in turn is defined by the \<map topology> and by the \<map appearance>. The \<map topology> defines how the map is going to \<be> and depends on the algorithm used to generate it, whereas the \<map appearance> defines how the map is going to \<look> and depends on how the map is assembled. This implies that the map type defines a whole array of procedurally generated maps that share the same topology and appearance. Therefore, when referring to a match we are considering a specific game-mode played in a procedurally generated map. If needed, it is possible to use a pre-generated map instead of generating a new one, by providing it as input in one of the supported formats. In this case the \<map topology> defines how to interpret the input, that is then displayed considering the \<map appearance>.

\par

A match is defined by combining different modular \<Manager> objects, each of which controls a different aspect of the match. To assure their interchangeability, most modules are defined by their own abstract class.

\subsection{The Game Manager}

The \<Game Manager> is the module responsible for the overall behavior of a match. Each game mode consists in a different implementation of the \<Game Manager>. It leans on the \<Map Manager> for the generation and the assembly of the map and on the \<Spawn Point Manager> for the spawn of entities. The \<Game Manager> controls the life-cycle of the match, that can be divided in the following phases:

\begin{itemize}
\item \<Setup>, all the modules are initialized.
\item \<Generation>, the \<Map Manager> generates or imports the map and assembles it.
\item \<Ready>, the \<Game Manager> displays a countdown announcing the start of the game.
\item \<Play>, the \<Game Manager> handles the game while the \<Experiment Manager> logs the actions of the player, if needed. This phase continues until an end condition is satisfied.
\item \<Score>, the \<Game Manager> stops the game and displays the final score.
\end{itemize}

\subsection{The Spawn Point Manager}

The \<Spawn Point Manager> contains a list of all the spawn points displaced on the map, that is populated during the \<Generation> phase by the \<Game Manager>. When the \<Game Manager> needs to spawn an entity, the \<Spawn Point Manager> provides a random spawn point from the ones that have not been used in a certain amount of time. If no spawn point meets this condition, the extraction is made from the complete pool.

\subsection{The Map Manager}

The \<Map Manager> controls the generation, the import and the assembly of the map and the displacement of objects inside it. It leans on the \<Map Generator> for the generation, on the \<Map Assembler> for the <assembly>\footnote{With \<assembly> we mean the operation of creating a 3D model of the map starting from its matrix representation.}, on the \<Object Displacer> for the \<displacement>\footnote{With \<displacement> we mean the operation of placing the 3D models of the objects in the assembled map, according to their position defined by the \<Map Generator> trough a \<positioning> algorithm.}, whereas it performs the import itself. If the map is provided as input, the \<Map Generator> is not called.

\par

Maps are represented as matrices of characters, where each character corresponds to a tile. Depending on the character, a tile can represent a wall, a room or an object inside a room. If a tile corresponds to a wall we say it is \<filled>, if it corresponds to a room we say it is \<empty>.
 
\subsection{The Map Generator}

The \<Map Generator> controls the generation of the map. Each implementation of the \<Map Generator> defines a different topology depending on the used generation algorithm and on how its parametric setting are tuned. Some of these setting are shared by all the implementations, whereas some of them are implementation-specific.

\par

The shared settings are used to define the size of the map and its encoding, to define the objects and to impose some constraints on their positioning:

\begin{itemize}
\item \<Width>, the width of the matrix that represents the map.
\item \<Height>, the height of the matrix that represents the map.
\item \<ObjectToObjectDistance>, the minimum number of cells that must separate two objects. 
\item \<ObjectToWallDistance>, the minimum number of cells  that must separate an objects and a wall.
\item \<BorderSize>, the width of the border placed all around the map once it has been generated, expressed in number of cells.
\item \<RoomChar>, the character used to represent a clear cell where the player can walk.
\item \<WallChar>,  the character used to represent a filled cell where the player can not walk.
\item \<MapObjects>, a list of the objects that must be placed in the map.
\end{itemize}

The objects contained in \<MapObjects> can represent spawn points, resources or decoration. They have the following properties:

\begin{itemize}
\item \<ObjectChar>, the character used to represent the object.
\item \<NumObjPerMap>,  the number of objects of that kind that must be placed in the map.
\item \<PlaceAnywhere>, if this value is set to true, the restriction on the distance from the walls is ignored.
\item \<PositioningMode>, the algorithm used to position the object in the map.
\end{itemize}

The framework provides three different algorithms to position the objects inside the map:

\begin{itemize}
\item \<Rain>, positions the objects selecting random cells from the ones that are empty and satisfy the  \<ObjectToWallDistance> constraint.
\item \<Rain Shared>, positions the objects selecting random cells from the ones that are empty and satisfy the  \<ObjectToWallDistance> constraint and the \<ObjectToObjectDistance> constraint on the objects that have been placed using \<Rain Shared>.
\item \<Rain Distanced>, positions the objects selecting random cells from the ones that are empty and satisfy the  \<ObjectToWallDistance> constraint and the \<ObjectToObjectDistance> constraint on the objects with the same \<ObjectChar>.
\end{itemize}

We now analyze the available implementations of the  \<Map Generator>.

\subsubsection{Cellular generation}

The \<Cellular Generator> employs a parametric \<cellular automaton>\footnote{A \<cellular automaton> consists of a grid of cells, each in one of a finite number of states, such as on and off. For each cell, a set of cells called its neighborhood is defined, usually composed by the cells that share at least one vertex with it (referred as \<8-neighbors>). Given the current state of the grid, a new generation is created, according to some fixed rule that determines the new state of each cell depending on the current state of the cell itself and of the cells in its neighborhood.} to generate a natural looking map. The algorithm (see Algorithm \ref{alg:cellular}) depends on the following parameters:

\begin{itemize}
\item \<RandomFillPercent>, the percentage of tiles that are randomly filled during the initialization of the algorithm.
\item \<SmoothingInteration>, the number of generations the cellular automaton is ran for.
\item \<NeighbourTileLimitLow>, the minimum number of neighbors a cell must have to became filled.
\item \<NeighbourTileLimitHigh>, the maximum number of neighbors a cell must have to became empty.
\item \<WallThresholdSize>, the minimum number of cells that an isolated filled region must include to not be deleted.
\item \<RoomThresholdSize>, the minimum number of cells that an isolated void region must include to not be deleted.
\item \<PassageWidth>, the width of a passage connecting two different areas, expressed in number of cells.
\end{itemize}

\par

% How these parameters influence the map

% Six different maps with different values

\begin{algorithm}[H]
\label{alg:cellular}
\SetAlgoLined

\For{every cell in the map}{
	empty the current cell\;
}

\While{the percentage of filled cells is less than RandomFillPercent} {
	select a random cell\;
	fill the selected cell\;
}

\For{\#SmoothingInteration iterations} {
	\For{every cell in the map}{
		count the 8-neighbors of the cell\;
		\If{the cell has more than NeighbourTileLimitLow neighbors}{
  			fill the current cell\;
   		}
		\If{the cell has less than NeighbourTileLimitHigh neighbors}{
  			empty the current cell\;
   		} 
	}
}

\For{every connected region of empty cells}{
	\If{the number of cells in the region is less than RoomThresholdSize}{
		fill all the cells in the region\;
	}
}

\For{every connected region of filled cells}{
	\If{the number of cells in the region is less than WallThresholdSize}{
		empty all the cells  in the region\;
	}
}

connect all the regions composed by filled cells\;
place the objects\;

\caption{Cellular generation algorithm}
\end{algorithm}

\subsubsection{Divisive generation}

\subsubsection{Random digger generation}

\subsubsection{Multi-level generation}

\subsection{The Map Assembler}

The \<Map Assembler> controls the assembly of the map. Each different implementation of the Map Assembler corresponds to a different appearance.

\subsection{The Object Displacer}

The \<Object Displacer> associates a character that represents neither a wall or a clear cell to the corresponding object, displacing it in the correct position. During this process, it populates a dictionary containing all the objects in the map divided by category, that is used by the \<Game Manager> to populate the list of spawn points used by the \<Spawn Point Manager>.

% MAP REPRESENTATION %

\section{Map representation}

% WEAPONS AND OBJECTS %

\section{Weapons and objects}

% GAME MODES %

\section{Game modes}

% LOGGING %

\section{Logging}

% EXPERIMENT MANAGEMENT %

\section{Experiment management}
